[내일배움캠프 사전캠프] + 언리얼 컴포넌트와 언리얼 C++ 이해 
======
***
## 1. 오늘 학습 키워드
***
### 언리얼 컴포넌트
***
+ 컴포넌트 정의
+ 메쉬 컴포넌트: 스태틱 메쉬와 스켈레탈 메쉬
+ 무브먼트 컴포넌트
+ 사운드 컴포넌트
+ 블루프린트 클래스의 정의와 블루프린트 클래스화
***
### 언리얼만의 C++ 전용 시스템
***
+ 리플렉션 시스템
+ 델리게이트와 이벤트 바인딩
+ 입력 시스템 구현
***
## 2. 오늘 학습 한 내용을 나만의 언어로 정리하기
***
### 언리얼 컴포넌트
***
### 1. 컴포넌트 정의

**컴포넌트(Component)**는 **액터(Actor)가 특정 기능이나 특성을 가질 수 있도록 정의하는 요소**이다. 

예를 들어, **Light Component**는 액터가 빛을 발하도록 하는 역할을 한다. 

컴포넌트는 액터가 다양한 기능을 수행할 수 있게 도와주는 **레고 부품**과 같은 역할을 한다.

예를 들어 언리얼의 Character 클래스의 기본 구성 요소를 살펴보면 다음과 같다.

- **캡슐 컴포넌트**: 충돌 감지 기능을 담당해 벽이나 오브젝트와의 충돌을 처리한다.
- **스켈레탈 메시 컴포넌트**: 캐릭터의 모델과 애니메이션 정보를 포함한다.
- **캐릭터 무브먼트 컴포넌트**: 캐릭터의 움직임을 제어한다.

또한 세부적인 컴포넌트별 기능이 다음과 같이 있다.

1. **캡슐 컴포넌트**: 충돌 처리를 통해 캐릭터가 벽을 뚫고 지나가지 않도록 한다.
2. **화살표 컴포넌트**: 캐릭터의 **현재 방향**을 나타낸다.
3. **메시 컴포넌트**: 캐릭터의 **모델과 애니메이션** 정보를 포함한다.
4. **카메라 붐 컴포넌트**: 캐릭터와 카메라 사이의 **거리를 유지**한다.
5. **카메라 컴포넌트**: 캐릭터를 플레이어 **화면에 표시**한다.

### 2. 메쉬 컴포넌트: 스태틱 메쉬와 스켈레탈 메쉬

**메쉬 컴포넌트**는 언리얼 엔진에서 3D 모델을 표현하는 핵심 요소이다. 

크게 **스태틱 메쉬(Static Mesh)**와 **스켈레탈 메쉬(Skeletal Mesh)** 두 가지로 나눠진다. 

이 두 메쉬 타입은 각각 고유한 용도와 특징을 가지고 있다.

>### 스태틱 메쉬 (Static Mesh)

- **스태틱 메쉬**는 움직이지 않는 고정된 3D 모델입니다. 건물, 나무, 바위와 같은 오브젝트가 대표적인 스태틱 메쉬이다.
- '스태틱'은 메시가 고정된 상태임을 의미하지만, 메쉬가 포함된 액터 자체는 움직일 수 있다.

>### 스켈레탈 메쉬 (Skeletal Mesh)

- 스켈레탈 메쉬는 **뼈대(스켈레톤)**를 가진 3D 모델로, **사람이나 동물처럼 움직임이 필요한 오브젝트에 사용한다.**
- 뼈대(Bone)를 기반으로 애니메이션을 적용할 수 있다.

>### 모빌리티 설정

모빌리티 옵션은 오브젝트의 이동 가능 여부와 조명 방식을 결정한다.

1. **Static (정적)**: 한 번 배치된 후에는 움직이거나 변형되지 않습니다. 조명을 미리 계산해 최적화된 성능을 제공한다.
2. **Stationary (스테이셔너리)**: 위치는 고정되지만, 조명 같은 속성은 실시간으로 조정된다.
3. **Movable (이동 가능)**: 자유롭게 이동 가능하며 실시간 조명을 사용합니다. 성능에 영향을 줄 수 있다.

### 3. 무브먼트 컴포넌트

언리얼 엔진에서는 움직임 요소를 별도로 관리하기 위해 **무브먼트 컴포넌트**를 사용하고 있다.

이는 엑터와 분리되어 캐릭터가 어떻게 움직일지, 속도는 얼마인지, 중력을 어떻게 받을지 등을 설정한다.

이를 통해 다양한 이동 패턴과 물리적 특성을 유연하게 적용할 수 있다.

>### 주요 무브먼트 컴포넌트 종류

1. **Character Movement Component**
    - 플레이어 캐릭터와 같은 생명체의 이동을 관리합니다.
    - 걷기, 달리기, 점프, 중력 등 복잡한 움직임을 처리합니다.
2. **Projectile Movement Component**
    - 총알이나 투사체처럼 발사된 물체의 이동을 담당합니다.
    - 직선 비행, 중력에 따른 낙하 등 다양한 투사체의 움직임을 설정할 수 있습니다.
3. **Floating Pawn Movement Component**
    - 드론과 같이 공중에서 움직이는 물체의 이동을 제어합니다.
    - 바닥에 닿지 않는 상태에서 이동하는 객체에 적합합니다.
  
### 4. 사운드 컴포넌트

언리얼 엔진에서 **사운드 컴포넌트**와 **오디오**는 게임 내 사운드를 구현하는 중요한 역할을 담당하고 있다.

사운드는 단순히 효과음을 재생하는 것 이상의 역할을 하며,

**게임 분위기 조성**, **사용자 경험 개선** 등의 핵심 요소로 활용하고 있다.

>### **사운드 컴포넌트(Sound Component)**

사운드 컴포넌트는 게임에서 소리를 재생하고 제어하는 역할을 담당 한다. 

예를 들어, **문이 열릴 때** 소리가 나거나 **발자국 소리**가 재생되는 등 특정 오브젝트에 소리를 부여할 수 있게 된다.

- **위치 기반 사운드**: 3D 공간에서 소리의 위치를 설정한다.
- **볼륨과 피치 조절**: 소리의 크기와 높낮이를 조절할 수 있다.
- **루프 재생**: 특정 소리를 반복해서 재생할 수 있다.

>### **오디오(Audio)**

오디오는 게임에서 사용하는 실제 **사운드 파일**을 가리킨다.

**WAV**, **MP3**, **OGG** 등의 파일 형식을 지원하며, 배경 음악(BGM)이나 효과음(SFX) 등 다양한 용도로 활용된다.

사운드를 여러 개 섞거나 랜덤하게 재생하려면 **사운드 큐(Sound Cue)**를 사용해야 한다.

### 5. 블루프린트 클래스의 정의

>### **블루프린트 클래스의 정의**

**블루프린트 클래스**는 언리얼에서 사용 가능한 C++ 클래스를 기반으로 한 시각적 스크립트이다.

이를 통해 언리얼 엔진의 다양한 기능과 오브젝트를 직접 조작할 수 있으며,

C++ 코드를 작성하지 않고도 게임 로직을 구현할 수 있다.

- **클래스 기반**: 기존의 **C++ 클래스**를 확장하거나 새롭게 생성할 수 있다.
  + 예를 들어, C++로 구현한 캐릭터 클래스를 기반으로 블루프린트 클래스를 만들고, 구체적인 동작과 기능을 정의할 수 있다.  
- **컴포넌트 기반**: 블루프린트 클래스에는 다양한 **컴포넌트**(예: 사운드 컴포넌트, 물리 컴포넌트 등)를 추가해 오브젝트에 다양한 기능을 설정할 수 있다.

***
### 언리얼만의 C++ 전용 시스템
***
### 1. 리플렉션 시스템

언리얼 엔진의 **리플렉션 시스템(Reflection System)**은 

엔진 내부에서 객체의 **클래스, 메서드, 변수의 정보**를 런타임에 접근하고 조작할 수 있게 해주는 강력한 메커니즘이다. 

이는 **C++ 클래스와 블루프린트 간의 상호작용**을 가능하게 해주며, 언리얼 엔진이 **동적 시스템**을 구현하는 데 필수적인 역할을 해준다.

리플렉션 시스템을 활용하면 런타임에 객체의 **메타데이터**에 접근해 **속성 수정, 함수 호출, 이벤트 처리** 등을 조작하는데 가능하다.

>### **리플렉션 시스템의 주요 개념**

1. **UCLASS, UPROPERTY, UFUNCTION 매크로**
    - 언리얼의 리플렉션 시스템은 **매크로**를 사용해 C++ 코드에서 메타데이터를 정의한다.
    - **UCLASS**, **UPROPERTY**, **UFUNCTION** 등의 매크로를 통해 클래스, 변수, 함수가 블루프린트나 에디터에서 노출될 수 있다.
2. **메타데이터(Metadata)**
    - 리플렉션 시스템은 메타데이터를 통해 객체에 대한 정보(속성 타입, 접근 권한 등)를 관리한다.
    - 이를 통해 변수와 함수의 가시성을 제어하고, **에디터에서 표시 여부**나 **블루프린트에서의 접근 가능성**을 설정할 수 있다.

>### **리플렉션을 활용한 C++와 블루프린트 통합**

리플렉션 시스템은 **C++ 클래스**를 블루프린트로 확장하거나, 

**블루프린트**에서 정의한 객체를 C++로 조작할 때 핵심 역할을 수행한다. 

이를 통해 개발자는 블루프린트와 C++의 장점을 결합해 유연한 작업을 할 수 있다.

>### **리플렉션 시스템의 주요 매크로 사용법**

#### 1. **UCLASS 매크로**

- 클래스를 리플렉션 시스템에 등록해준다.
- 이 매크로가 있어야 블루프린트에서 이 클래스를 기반으로 확장이 가능하다.

```cpp
UCLASS()
class MYPROJECT_API AMyActor : public AActor
{
    GENERATED_BODY()
};

```

---

### 2. **UPROPERTY 매크로**

- 변수를 리플렉션 시스템에 등록해준다.
- 블루프린트나 에디터에서 해당 변수를 사용하거나 조작할 수 있다.

```cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Stats")
int32 Health;

```

- **EditAnywhere**: 에디터에서 이 값을 수정할 수 있게 설정한다.
- **BlueprintReadWrite**: 블루프린트에서 읽고 쓸 수 있게 설정한다.
- **Category**: 변수의 속성을 그룹화해 에디터에서 보기 좋게 정리한다.

---

### 3. **UFUNCTION 매크로**

- 함수를 리플렉션 시스템에 등록해 블루프린트에서 호출할 수 있게 한다.

```cpp
UFUNCTION(BlueprintCallable, Category = "Combat")
void Attack();
```

- **BlueprintCallable**: 블루프린트에서 이 함수를 호출할 수 있다.

>### **리플렉션 시스템의 주요 기능**

1. **블루프린트 통합**:
    
    C++에서 정의한 클래스와 함수를 블루프린트에서 사용할 수 있게 해준다.
    
2. **런타임 조작**:
    
    리플렉션을 통해 런타임에 객체의 속성 값을 수정하거나 함수를 동적으로 호출할 수 있게 해준다.
    
3. **에디터 지원**:
    
    리플렉션 시스템을 사용하면 에디터에서 객체의 속성을 수정하고, 게임 로직을 테스트할 수 있게 해준다.
    

>### **리플렉션 시스템의 장점과 단점**

**장점**

- **블루프린트와 C++의 통합**이 용이하다.
- **런타임 조작**이 가능해 게임의 유연성을 높인다.
- **에디터 지원**을 통해 개발 속도가 빨라진다.

**단점**

- 코드가 복잡해질 수 있으며, 성능에 약간의 영향을 미칠 수 있다.
- 메타데이터를 잘못 설정하면 디버깅이 어려워질 수 있다.
***
### 2. 델리게이트와 이벤트 바인딩

### **1. 델리게이트(Delegate)란?**

델리게이트는 **특정 이벤트나 동작 발생 시 호출할 함수를 미리 등록**해두는 일종의 **콜백 메커니즘**이다.

이는 **C++의 함수 포인터**와 비슷한 역할을 하며, 다양한 시점에서 실행할 함수를 외부에서 설정할 수 있게 한다.

델리게이트는 코드의 **결합도를 낮추고**, **유연한 이벤트 처리**를 가능하게 해주는 역할을 한다.

---

**델리게이트의 사용 예시**

- **캐릭터가 죽을 때** 호출될 함수를 델리게이트에 등록해, 사망 이벤트 발생 시 자동으로 처리한다.
- **UI 버튼을 클릭했을 때**, 델리게이트를 통해 UI를 업데이트하거나 새로운 기능을 실행한다.

### **2. 델리게이트의 주요 유형**

**일반 델리게이트**

- **하나의 함수**만 등록하고 호출한다.
- 간단한 이벤트 처리에 유용하다.

**멀티캐스트 델리게이트**

- **여러 개의 함수**를 한 번에 바인딩할 수 있다.
- 하나의 이벤트에 **다양한 반응**이 필요한 경우 유용하다.

**동적 델리게이트**

- **런타임**에 바인딩하거나 해제할 수 있다.
- **블루프린트**와 상호작용이 필요할 때 사용된된다.

### **3. 델리게이트 선언과 사용 예제**

```cpp
// 멀티캐스트 동적 델리게이트 선언
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnCharacterDeath);

class AMyCharacter : public ACharacter
{
    GENERATED_BODY()

public:
    // 캐릭터가 죽을 때 호출될 델리게이트
    FOnCharacterDeath OnCharacterDeath;

    void Die()
    {
        // 사망 시 연결된 함수들을 호출
        OnCharacterDeath.Broadcast();
    }
};
```

위 예제에서, 캐릭터가 사망할 때 `OnCharacterDeath.Broadcast()`를 통해 연결된 모든 함수를 호출한한다.

---

### **4. 이벤트 바인딩(Event Binding)과 사용 방법**

이벤트 바인딩은 **특정 이벤트가 발생할 때 호출할 함수**를 델리게이트에 연결하는 과정이다. 이를 통해 이벤트 발생 시 미리 바인딩된 함수가 자동으로 호출한다.

```cpp
void AMyGameMode::BeginPlay()
{
    Super::BeginPlay();

    // 캐릭터 사망 이벤트에 함수 바인딩
    MyCharacter->OnCharacterDeath.AddDynamic(this, &AMyGameMode::HandleCharacterDeath);
}

void AMyGameMode::HandleCharacterDeath()
{
    // 캐릭터가 죽었을 때 실행할 로직
    UE_LOG(LogTemp, Warning, TEXT("캐릭터가 죽었습니다!"));
}
```

**핵심 메서드**

- **`AddDynamic()`**: 런타임 중에 동적으로 함수를 델리게이트에 바인딩한다.
- **`Broadcast()`**: 바인딩된 모든 함수를 호출한다.

### **5. 델리게이트와 이벤트 바인딩의 장점**

- **유연한 이벤트 처리**: 여러 함수들을 런타임 중에 자유롭게 바인딩하거나 해제할 수 있다.
- **모듈화된 코드**: 이벤트와 동작을 분리해 코드의 가독성과 유지보수성을 높여준다.
- **블루프린트와 통합**: 동적 델리게이트를 활용해 블루프린트와의 상호작용을 쉽게 구현할 수 있다.
***
### 3. 입력 시스템 구현

언리얼 엔진 5의 **향상된 입력 시스템(Enhanced InputSystem)**은 기존 입력 시스템을 확장하여 더 **유연하고 강력한 입력 처리** 기능을 제공한다.

다양한 입력 장치(키보드, 마우스, 게임패드 등)를 동시에 지원하며, **복잡한 입력 패턴과 매핑**을 보다 쉽게 처리할 수 있도록 설계되었다.

이 시스템은 **입력 컨텍스트**, **모듈화된 액션**, **고급 입력 이벤트** 등을 활용해 **게임플레이의 유연성**을 크게 향상시킨다.

>### **주요 특징**

1. **입력 액션 (Input Actions)**
    
    **Input Actions**는 다양한 입력 동작을 **모듈화된 객체**로 정의한다.

    이를 통해 **키보드, 마우스 클릭, 게임패드, 멀티터치 제스처**와 같은 입력을 하나의 액션으로 처리할 수 있게 해준다.
    
3. **입력 컨텍스트 (Input Contexts)**
    
    **Input Context**는 **게임의 특정 상황**에서만 활성화되는 입력 매핑을 정의한다.

    예를 들어, 캐릭터가 조준 모드에 있을 때는 해당 입력만 처리하고, UI를 조작할 때는 다른 입력을 비활성화할 수 있게 해준준다.
    
5. **1.3 고급 입력 처리**
    - **Hold**: 키를 일정 시간 이상 누르면 특정 행동이 트리거된다.
    - **Double Press**: 더블 클릭을 감지해 동작을 수행한다.
    - **Combo Actions**: 연속된 입력으로 **콤보 공격** 같은 복잡한 동작을 구현하게 해준다.
6. **멀티 디바이스 입력 지원**
    
    여러 입력 장치를 **동시에** 사용할 수 있게 해준다. 예를 들어, 플레이어는 게임패드로 이동하면서 키보드로 추가 명령을 내릴 수 있다.
    

### **구성 요소**

1. **Input Action**
    
    **Input Action**은 특정 입력 이벤트(누름, 축 값 등)를 정의한 객체다. 
    
    주요 유형:
    
    - **디지털 입력**: 버튼 클릭과 같은 이진 입력 처리.
    - **축 입력**: 조이스틱이나 마우스 이동 같은 연속적인 값 처리.
2. **Input Mapping Context**
    
    `Input Mapping Context`는 **게임 모드나 상황에 맞는 입력 매핑**을 정의한다.
    예를 들어, **UI 조작 모드**와 **게임플레이 모드**에서 입력 처리를 다르게 설정할 수 있다.
    
4. **Enhanced Player Input Component**
    
    기존 **PlayerInputComponent**를 확장한 **Enhanced Player Input Component**는 다양한 입력 액션을 처리하며, 각 액션에 조건과 반응을 정의할 수 있다   
***

## 3. 내일 학습 할 것은 무엇인지

내일은 우선 C++ 3주차 강의를 진행하면서 직접 TPS(3인칭) 캐릭터를 만들고 거기에 애니메이션과 UI를 C++을 통해 추가할 예정이다.

#내일배움캠프 #사전캠프 #TIL 
 
